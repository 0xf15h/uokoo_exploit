import sys
import argparse
import hexdump
import struct
import socket
import os
import zipfile
import pathlib


PORT: int = 65531
DEBUG: bool = False
AUTH_MESSAGE_SIZE: int = 0x30


class AuthenticationMessage:
    def __init__(self):
        self.unknown: bytes = b"\x00" * 4
        self.username: str = str()
        self.password: str = str()

    def __bytes__(self) -> bytes:
        ret: bytes = self.unknown
        ret += align(self.username.encode("utf-8"), 32)
        ret += align(self.password.encode("utf-8"), 32)
        return ret


class UpdateHeader:
    def __init__(self):
        self.magic: bytes = "HY01".encode("utf-8")
        self.crc: bytes = b"\x00" * 4  # Not checked server-side
        self.compressed_update_size: int = 0
        self.decompressed_update_size: int = 0
        self.update_flag: bytes = b"\x00"
        self.padding_1: bytes = b"\x00\x00"
        self.hardware_version = b"\x00" * 2  # Not checked when the magic is set to HY01
        self.padding_2: bytes = b"\x00" * 27

    def __bytes__(self) -> bytes:
        ret: bytes = self.magic
        ret += self.crc
        ret += struct.pack("<I", self.compressed_update_size)
        ret += struct.pack("<I", self.decompressed_update_size)
        ret += self.update_flag
        ret += self.padding_1
        ret += self.hardware_version
        ret += self.padding_2
        return ret


def align(data: bytes, alignment: int) -> bytes:
    return data + b"\x00" * (alignment - len(data))


def zip_update_payload() -> bytes:
    """
    Recursively zips the mnt directory to create the update payload.
    :return: The update payload zip file in bytes.
    """
    zip_file = zipfile.ZipFile("payload.zip", "w", zipfile.ZIP_DEFLATED)
    for root, dirs, files in os.walk("./mnt"):
        for file in files:
            zip_file.write(os.path.join(root, file))
    zip_file.close()

    with open("payload.zip", "rb") as payload_file:
        update_payload: bytes = payload_file.read()

    if not DEBUG:
        os.remove("payload.zip")

    return update_payload


def send_authentication_message(s: socket.socket, username: str, password: str):
    """
    Creates and sends the authentication message to the IP camera.
    :param s: The socket connection to the IP camera.
    :param username: The username to authenticate with.
    :param password: The password to authenticate with.
    :return: None
    """
    auth_msg = AuthenticationMessage()
    auth_msg.username = username
    auth_msg.password = password

    auth_msg_bytes = bytes(auth_msg)
    if DEBUG:
        hexdump.hexdump(auth_msg_bytes)
    s.sendall(auth_msg_bytes)


def send_update_header(s: socket.socket, compressed_size: int, decompressed_size: int):
    """
    Creates and sends the update header to the IP camera.
    :param s: The socket connection to the IP camera.
    :param compressed_size: The compressed size of the update header + payload.
    :param decompressed_size: The decompressed size of the payload (i.e. the sum of all the file sizes in the payload).
    :return: None
    """
    update_hdr = UpdateHeader()
    update_hdr.compressed_update_size = compressed_size + AUTH_MESSAGE_SIZE
    update_hdr.decompressed_update_size = decompressed_size

    update_hdr_bytes = bytes(update_hdr)
    if DEBUG:
        hexdump.hexdump(update_hdr_bytes)
    s.sendall(update_hdr_bytes)


def success(s: socket.socket) -> bool:
    """
    Checks if the server responds with the "HY01" success message.
    :return: True if successful, otherwise False
    """
    success_response: bytes = "HY01".encode("utf-8") + b"\x00" * 4
    response: bytes = s.recv(8)
    if DEBUG:
        print("[*] Response from the server")
        hexdump.hexdump(response)
    return response == success_response


def main(ip_address: str, username: str, password: str):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, PORT))

    update_payload: bytes = zip_update_payload()
    compressed_size: int = len(update_payload)
    root_directory = pathlib.Path("./mnt")
    decompressed_size: int = sum(
        file.stat().st_size for file in root_directory.glob("**/*") if file.is_file()
    )
    if DEBUG:
        print(f"Compressed size: {compressed_size:x}")
        print(f"Decompressed size: {decompressed_size:x}")

    send_authentication_message(s, username, password)
    if success(s):
        print("[+] Successfully authenticated")
    else:
        print("[-] Authentication message failed")
        s.close()
        sys.exit(1)

    send_update_header(s, compressed_size, decompressed_size)
    if success(s):
        print("[+] Sent update header")
    else:
        print("[-] Update header failed")
        s.close()
        sys.exit(1)

    s.sendall(update_payload)
    if success(s):
        print("[+] Update payload sent! The device should reboot in a few seconds...")
    else:
        print("[-] Update payload failed")
        s.close()
        sys.exit(1)


if __name__ == "__main__":
    if sys.version_info[0] < 3 or sys.version_info[1] < 6:
        print("[-] Python version 3.6 or higher is required")
        sys.exit(1)

    parser = argparse.ArgumentParser()
    parser.add_argument("ip_address", type=str)
    parser.add_argument("--username", default="admin", type=str)
    parser.add_argument("--password", default="123456", type=str)
    args = parser.parse_args()

    if len(args.username) > 32:
        print("[-] Username is longer than 32 characters")
        sys.exit(1)
    if len(args.password) > 32:
        print("[-] Password is longer than 32 characters")
        sys.exit(1)

    main(args.ip_address, args.username, args.password)
